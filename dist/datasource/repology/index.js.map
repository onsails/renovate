{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../lib/datasource/repology/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { HOST_DISABLED } from '../../constants/error-messages';\nimport { logger } from '../../logger';\nimport { ExternalHostError } from '../../types/errors/external-host-error';\nimport * as packageCache from '../../util/cache/package';\nimport { Http } from '../../util/http';\nimport { GetReleasesConfig, ReleaseResult } from '../common';\n\nexport const id = 'repology';\n\nconst http = new Http(id);\nconst cacheNamespace = `datasource-${id}`;\nconst cacheMinutes = 60;\n\nexport type RepologyPackageType = 'binname' | 'srcname';\nconst packageTypes: RepologyPackageType[] = ['binname', 'srcname'];\n\nexport interface RepologyPackage {\n  repo: string;\n  visiblename: string;\n  version: string;\n  srcname?: string;\n  binname?: string;\n  origversion?: string;\n}\n\nasync function queryPackages(url: string): Promise<RepologyPackage[]> {\n  try {\n    const res = await http.getJson<RepologyPackage[]>(url);\n    return res.body;\n  } catch (err) {\n    if (err.statusCode === 404) {\n      // Return an array here because the api does not return proper http codes\n      // and instead of an 404 error an empty array with code 200 is returned\n      // When querying the resolver 404 is thrown if package could not be resolved\n      // and 403 if the repo is not supported\n      // 403 is handled later because in this case we are trying the API\n      return [];\n    }\n\n    throw err;\n  }\n}\n\nasync function queryPackagesViaResolver(\n  repoName: string,\n  packageName: string,\n  packageType: RepologyPackageType\n): Promise<RepologyPackage[]> {\n  const query = new URLSearchParams({\n    repo: repoName,\n    name_type: packageType,\n    target_page: 'api_v1_project',\n    noautoresolve: 'on',\n    name: packageName,\n  }).toString();\n\n  // Retrieve list of packages by looking up Repology project\n  const packages = await queryPackages(\n    `https://repology.org/tools/project-by?${query}`\n  );\n\n  return packages;\n}\n\nasync function queryPackagesViaAPI(\n  packageName: string\n): Promise<RepologyPackage[]> {\n  // Directly query the package via the API. This will only work if `packageName` has the\n  // same name as the repology project\n  const packages = await queryPackages(\n    `https://repology.org/api/v1/project/${packageName}`\n  );\n\n  return packages;\n}\n\nfunction findPackageInResponse(\n  response: RepologyPackage[],\n  repoName: string,\n  pkgName: string,\n  types: RepologyPackageType[]\n): RepologyPackage | undefined {\n  let pkgs = response.filter((pkg) => pkg.repo === repoName);\n\n  // In some cases Repology bundles multiple packages into a single project,\n  // which would result in ambiguous results. If we have more than one result\n  // left, we should try to determine the correct package by comparing either\n  // binname or srcname (depending on `types`) to the given dependency name.\n  if (pkgs.length > 1) {\n    for (const pkgType of types) {\n      pkgs = pkgs.filter((pkg) => !pkg[pkgType] || pkg[pkgType] === pkgName);\n      if (pkgs.length === 1) {\n        break;\n      }\n    }\n  }\n\n  // Abort if there is still more than one package left, as the result would\n  // be ambiguous and unreliable. This should usually not happen...\n  if (pkgs.length > 1) {\n    logger.warn(\n      { repoName, pkgName, packageTypes, pkgs },\n      'Repology lookup returned ambiguous results, ignoring...'\n    );\n    return null;\n  }\n\n  // pkgs might be an empty array here and in that case we return undefined\n  return pkgs[0];\n}\n\nasync function queryPackage(\n  repoName: string,\n  pkgName: string\n): Promise<RepologyPackage> {\n  let response: RepologyPackage[];\n  let pkg: RepologyPackage;\n  // Try getting the packages from tools/project-by first for type binname and\n  // afterwards for srcname. This needs to be done first, because some packages\n  // resolve to repology projects which have a different name than the package\n  // e.g. `pulseaudio-utils` resolves to project `pulseaudio`, BUT there is also\n  // a project called `pulseaudio-utils` but it does not contain the package we\n  // are looking for.\n  try {\n    for (const pkgType of packageTypes) {\n      response = await queryPackagesViaResolver(repoName, pkgName, pkgType);\n\n      pkg = findPackageInResponse(response, repoName, pkgName, [pkgType]);\n      if (pkg) {\n        // exit immediately if package found\n        return pkg;\n      }\n    }\n  } catch (err) {\n    if (err.statusCode === 403) {\n      logger.debug(\n        { repoName, pkgName },\n        'Repology does not support tools/project-by lookups for repository. Will try direct API access now'\n      );\n\n      // If the repository is not supported in tools/project-by we try directly accessing the\n      // API. This will support all repositories but requires that the project name is equal to the\n      // package name. This won't be always the case but for a good portion we might be able to resolve\n      // the package this way.\n      response = await queryPackagesViaAPI(pkgName);\n      pkg = findPackageInResponse(response, repoName, pkgName, packageTypes);\n      if (pkg) {\n        // exit immediately if package found\n        return pkg;\n      }\n    }\n    throw err;\n  }\n\n  logger.debug(\n    { repoName, pkgName },\n    'Repository or package not found on Repology'\n  );\n\n  return null;\n}\n\nasync function getCachedPackage(\n  repoName: string,\n  pkgName: string\n): Promise<RepologyPackage> {\n  // Fetch previous result from cache if available\n  const cacheKey = `${repoName}/${pkgName}`;\n  const cachedResult = await packageCache.get<RepologyPackage>(\n    cacheNamespace,\n    cacheKey\n  );\n  // istanbul ignore if\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  // Attempt a package lookup and return if successfully\n  const pkg = await queryPackage(repoName, pkgName);\n  if (pkg) {\n    await packageCache.set(cacheNamespace, cacheKey, pkg, cacheMinutes);\n    return pkg;\n  }\n\n  // No package was found on Repology\n  return null;\n}\n\nexport async function getReleases({\n  lookupName,\n}: GetReleasesConfig): Promise<ReleaseResult | null> {\n  // Ensure lookup name contains both repository and package\n  const [repoName, pkgName] = lookupName.split('/', 2);\n  if (!repoName || !pkgName) {\n    throw new ExternalHostError(\n      new Error(\n        'Repology lookup name must contain repository and package separated by slash (<repo>/<pkg>)'\n      )\n    );\n  }\n\n  logger.trace(`repology.getReleases(${repoName}, ${pkgName})`);\n  try {\n    // Attempt to retrieve (cached) package information from Repology\n    const pkg = await getCachedPackage(repoName, pkgName);\n    if (!pkg) {\n      return null;\n    }\n\n    // Always prefer origversion if available, otherwise default to version\n    // This is required as source packages usually have no origversion\n    const version = pkg.origversion ?? pkg.version;\n    return { releases: [{ version }] };\n  } catch (err) {\n    if (err.message === HOST_DISABLED) {\n      // istanbul ignore next\n      logger.trace({ lookupName, err }, 'Host disabled');\n    } else {\n      logger.warn(\n        { lookupName, err },\n        'Repology lookup failed with unexpected error'\n      );\n    }\n\n    throw new ExternalHostError(err);\n  }\n}\n"]}